#version 430
layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

#include "VHM_MinMaxLODNum.glsl"
#include "VHM_WorldLODParam.glsl"

layout(binding = 0) uniform atomic_uint index_B;
layout(binding = 1) uniform atomic_uint index_Final;

layout(std430, binding=2) readonly buffer NodeIDs_TempA_Buffer{
    uvec2 NodeIDs_TempA[];
};
layout(std430, binding=3) writeonly buffer NodeIDs_TempB_Buffer{
    uvec2 NodeIDs_TempB[];
};
layout(std430, binding=4) writeonly buffer NodeIDs_Final_Buffer{
    uvec4 NodeIDs_Final[];
};
layout(std430, binding=5) readonly buffer LODParams_Buffer{
    WorldLODParam LODParams[];
};
layout(std430, binding=6) writeonly buffer NodeDescription_Buffer{
    uint NodeDevided[];
};

layout(std140) uniform FCreateNodeListBlock {
    uint MaxLOD;
    uint PassLOD;
    float ScreenSizeDenominator;
};

layout (std140) uniform FPrimitiveShaderParameters {
    dmat4 LocalToWorld;
};

#include "../include/ViewShaderParameters.glsl"

uniform sampler2D MinMaxMap;

//float GetNodeSize(uint lod)
//{
//    return LODParams[lod].NodeMeterSize;
//}
dvec4 GetNodePositionWS(uvec2 nodeLoc, uint lod)
{
    vec2 xy_center_coord = (vec2(nodeLoc) + vec2(0.5)) * vec2(LODParams[lod].NodeMeterSize_x, LODParams[lod].NodeMeterSize_y);
    vec2 uv = (vec2(nodeLoc) + vec2(0.5)) / vec2(LODParams[lod].NodeSideNum_x, LODParams[lod].NodeSideNum_y);
    vec2 minmax = textureLod(MinMaxMap, uv, float(lod+3)).rg;
    float height = (minmax.r + minmax.g) / 2;
    return LocalToWorld * dvec4(xy_center_coord, height, 1);
}
bool MeetScreenSize(uvec2 nodeLoc, uint lod){
    dvec4 positionWS = GetNodePositionWS(nodeLoc, lod);
    float dis = float(distance(dvec3(CameraPosition), dvec3(positionWS)));
    float nodeSize = max(LODParams[lod].NodeMeterSize_x, LODParams[lod].NodeMeterSize_y) * 0.1;
    float ScreenSize = nodeSize * CameraResolution.y / (dis * ScreenSizeDenominator);
    return ScreenSize < 500;
//    float f = dis / (nodeSize * 1.5);
//    if (f < 1) 
//        return false;
//    return true;
}

void main()
{
    uvec2 nodeLoc;
    if (PassLOD == MaxLOD)
    {
        uint i = gl_GlobalInvocationID.x / LODParams[PassLOD].NodeSideNum_x;
        uint j = gl_GlobalInvocationID.x % LODParams[PassLOD].NodeSideNum_x;
        nodeLoc = uvec2(i, j);//NodeIDs_TempA[gl_GlobalInvocationID.x];
    }
    else
    {
        nodeLoc = NodeIDs_TempA[gl_GlobalInvocationID.x];
    }
    uint index = fromNodeLoctoNodeDescriptionIndex(nodeLoc, PassLOD, LODParams[PassLOD]);
    if(PassLOD > 0 && !MeetScreenSize(nodeLoc, PassLOD)){
        //divide
        uint i = atomicCounterIncrement(index_B);
        NodeIDs_TempB[i] = nodeLoc * 2;
        i = atomicCounterIncrement(index_B);
        NodeIDs_TempB[i] = nodeLoc * 2 + uvec2(1,0);
        i = atomicCounterIncrement(index_B);
        NodeIDs_TempB[i] = nodeLoc * 2 + uvec2(0,1);
        i = atomicCounterIncrement(index_B);
        NodeIDs_TempB[i] = nodeLoc * 2 + uvec2(1,1);
        NodeDevided[index] = 1;
    }
    else
    {
        // 曾经尝试对提前对Node进行剪裁，但是似乎帧率还不如在后面对patch剪裁
        NodeDevided[index] = 0;

//        vec2 uv = (vec2(nodeLoc) + vec2(0.5)) / float(LODParams[PassLOD].NodeSideNum);
//        vec2 MinMax = texture2D(MinMaxMap[PassLOD+3], uv).rg;
//        vec2 upper_left = vec2(nodeLoc) * LODParams[PassLOD].NodeMeterSize;
//        vec2 lower_right = upper_left + vec2(LODParams[PassLOD].NodeMeterSize);
//        vec3 box[8];
//        CreateBox(upper_left, lower_right, MinMax, box);
//        if (FrustumCull(box))
//            return;
        
        uint i = atomicCounterIncrement(index_Final);
        NodeIDs_Final[i].x = nodeLoc.x;
        NodeIDs_Final[i].y = nodeLoc.y;
        NodeIDs_Final[i].z = PassLOD;
        
//        NodeIDs_Final[i] = uvec3(nodeLoc, PassLOD);
    }
//    NodeIDs_Final[gl_GlobalInvocationID.x] = uvec3(gl_GlobalInvocationID.x, gl_GlobalInvocationID.x, gl_GlobalInvocationID.x);
}